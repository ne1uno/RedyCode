<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--

	Nonzero1.0 by nodethirtythree design
	http://www.nodethirtythree.com
	missing in a maze

-->
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<title>OpenEuphoria: Euphoria v4.1</title>
	<meta name="keywords" content="" />
	<meta name="description" content="" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<script src="js/search.js" type="text/javascript"></script>
</head>
<body>
<div id="header">
		<div id="header_inner" class="fluid">
			<div id="logo">
				<h1><a href="index.html"><span>Open</span>Euphoria Manual</a></h1>
				<h2>Euphoria v4.1</h2>
			</div>
		</div>
	</div>

	<div id="main">
		<div id="main_inner" class="fluid">
			<div id="docs">
	<form method=get action="javascript:void(0)" onsubmit="search(srchval); return false;">
	<table width="100%" border=0 padding=0 cellpadding=0>
		<tr align="left">
			<td>
			<b>routine</b> or <b>constant</b> name search</td>
		</tr>
		<tr>	
			<td><input type=text name=srchval value=""><input type=submit></td>
		</tr>
		<tr>
		<td><span id="searchresults" name="searchresults"></td></span>
	</table>
	</form>
						<!-- BEGIN NAV -->
						<div class="doc-tools">
							<table border=0 padding=0 cellpadding=0 width="100%">
								<tr>
									<td><a href="trouble.html"><img src="images/prev.png" /></a></td>
									<td><a href="miniguide.html">Up</a></td>
									<td><a href="perform.html"><img src="images/next.png" /></a></td>
									<!-- Spacer -->
									<td width="100%" colspan="3">&nbsp;</td>
									<td><a href="index.html">TOC</a></td>
									<td><a href="key_index.html">Index</a></td>
								</tr>
								<tr>
									<td width="20%" colspan="3">
										&lt;&lt;
										<a href="syntax_toc.html">5 Formal Syntax</a>
									</td>
									<td width="20%">
										&lt;
										<a href="trouble.html">6.9 Euphoria Trouble-Shooting Guide</a>
									</td>
									<td width="20%">
										Up: <a href="miniguide.html">6 Mini-Guides</a>
									</td>
									<td width="20%">
										<a href="perform.html">6.11 Performance Tips</a>
										&gt;
									</td>
									<td width="20%" colspan="2">
										<a href="tools.html">7 Included Tools</a>
										&gt;&gt;
									</td>
								</tr>
							</table>
						</div>
						<!-- END NAV -->

						<div class="body">
							</p>

<!-- ..\docs\platform.txt -->
<h2>6.10 Platform Specific Issues</h2>
<a name="_640_platformspecificissues"></a><a name="platformspecificissues"></a>
<p> <div style="margin-left:2em"><div class="TOC">
<div class="TOCBody"><div class="toc_2"><a href="platform.html#_640_platformspecificissues">6.10 Platform Specific Issues</a></div>
<div class="toc_3"><a href="platform.html#_641_introduction">6.10.1 Introduction</a></div>
<div class="toc_3"><a href="platform.html#_642_thediscontinueddos32platform">6.10.2 The Discontinued DOS32 Platform</a></div>
<div class="toc_3"><a href="platform.html#_643_thewindowsplatform">6.10.3 The Windows Platform</a></div>
<div class="toc_4"><a href="platform.html#_644_highlevelwindowsprogramming">6.10.3.1 High-Level Windows Programming</a></div>
<div class="toc_4"><a href="platform.html#_645_lowlevelwindowsprogramming">6.10.3.2 Low-Level WINDOWS Programming</a></div>
<div class="toc_3"><a href="platform.html#_646_theunixplatforms">6.10.4 The Unix Platforms</a></div>
<div class="toc_3"><a href="platform.html#_647_interfacingwithccode">6.10.5 Interfacing with C Code</a></div>
<div class="toc_4"><a href="platform.html#_648_callingcfunctions">6.10.5.1 Calling C Functions</a></div>
<div class="toc_4"><a href="platform.html#_649_accessingcvariables">6.10.5.2 Accessing C Variables</a></div>
<div class="toc_4"><a href="platform.html#_650_accessingcstructures">6.10.5.3 Accessing C Structures</a></div>
<div class="toc_4"><a href="platform.html#_651_callbackstoyoureuphoriaroutines">6.10.5.4 Call-backs to your Euphoria routines</a></div>
</div>
</div>
</p>
</div>
<!-- ..\docs\platform.txt -->
<h3>6.10.1 Introduction</h3>
<a name="_641_introduction"></a><a name="introduction"></a>
<p> OpenEuphoria currently supports Euphoria on many different <strong>platforms</strong>. More platforms will be added in the future.</p>

<p> <a href="platform.html#_642_thediscontinueddos32platform">**DOS**</a> platform support has been discontinued.</p>

<p> <a href="platform.html#_643_thewindowsplatform">**Windows**</a> in particular, the 32-bit x86 compatible version of<em>Windows</em>. The minimum version is Windows 95 Original Equipment Manufacturer Service Release 2.5. EUPHORIA will work on all old and new versions of <em>Windows</em> written after Windows 95. However, to use all of the features you must use Windows XP or later.  See ''.</p>

<p> <strong>Linux</strong>. Linux is inspired by the UNIX operating system. It has recently become very popular on PCs. There are many distributors of Linux, including Red Hat, Debian, Ubuntu, and many more. Linux can be obtained on a CD for a very low price. Linux is an open-source operating system.</p>

<p> <strong>FreeBSD</strong>. FreeBSD is also based on the UNIX operating system. It is very popular on  Internet server machines. It's also open source.</p>

<p> Apple's <strong>OS X</strong>. OS X is also based on the UNIX operating system. While it is closed source, it is gaining a wide following due to it's ease of use and power.</p>

<p> <strong>OpenBSD</strong>. Open BSD is also a UNIX-like Operating System and is developed by volunteers.</p>

<p> <strong>NetBSD</strong>. Net BSD is also a UNIX-like Operating System  and is designed to be easily  portable to other hardware platforms.</p>

<p> Euphoria source files use various file extensions. The common extensions are:</p>
<table><tr><th>extension </th>
<th> application </th>
</tr>
<tr><td> .e </td>
<td> Euphoria include file </td>
</tr>
<tr><td> .ew </td>
<td> Euphoria include file for a Windowed (GUI) application only </td>
</tr>
<tr><td> .ex </td>
<td> Console main program file <br />
or any executable program </td>
</tr>
<tr><td> .exw </td>
<td> Windowed (GUI) main program file<br />
or a <em>Windows</em> specific program </td>
</tr>
<tr><td> .exu </td>
<td> Unix specific program </td>
</tr>
</table>

<p> It is convenient to use these file extensions, but they are not mandatory. </p>

<p> The Euphoria for <em>Windows</em> installation file contains <strong>eui.exe</strong>. It runs Euphoria programs on the <em>Windows</em> 32bit platform.</p>

<p> The Euphoria for <em>Linux</em> .tar file contains only <strong>eui</strong>. It runs Euphoria programs on the Linux platform.</p>

<p> Other versions of Euphoria are installed by first installing the Linux version of Euphoria, replacing eui with the version of eui for that Operating System, then rebuilding the other binaries from the source.</p>

<p> Sometimes you'll find that the majority of your code will be the same on all platforms, but some small parts will have to be written differently for each platform. Use the <a href="syntax.html#_205_ifdef">ifdef</a> statement to tell you <a href="lang_branch.html#_154_platformdefinitions">which platform you are currently running on</a>.</p>

<p> You can also use the <a href="std_console.html#_959_platform">platform</a> and <a href="euphoria_info.html#_6100_platform_name">platform_name</a> functions:</p>

<pre class="examplecode"><font color="#0000FF">printf</font><font color="#880033">(</font><font color="#330033">1, </font><font color="#330033">"Our platform number is: %d"</font><font color="#330033">, </font><font color="#993333">{</font><font color="#0000FF">platform</font><font color="#0000FF">()</font><font color="#993333">}</font><font color="#880033">)</font>
</pre>

<p> The evaluation of <tt>platform</tt> occurs at 'runtime', you may even use a switch statement with it.</p>

<pre class="examplecode"><font color="#0000FF">switch platform</font><font color="#880033">() </font><font color="#0000FF">do</font>
<font color="#0000FF">    case </font><font color="#330033">WINDOWS </font><font color="#0000FF">then</font>
<font color="#FF0055">       -- Windows code</font>
<font color="#0000FF">    case </font><font color="#330033">LINUX </font><font color="#0000FF">then</font>
<font color="#FF0055">       -- LINUX code</font>
<font color="#0000FF">    case </font><font color="#330033">FREEBSD,NETBSD </font><font color="#0000FF">then</font>
<font color="#FF0055">       -- BSD code</font>
<font color="#330033">       ... etc</font>
<font color="#0000FF">    case else</font>
<font color="#330033">       crash</font><font color="#880033">(</font><font color="#330033">"Unsupported platform"</font><font color="#880033">)</font>
<font color="#0000FF">end switch</font>
</pre>

<p> Another way is to use parse-time evaluation using ifdefs.  </p>

<pre class="examplecode"><font color="#0000FF">ifdef </font><font color="#330033">WINDOWS </font><font color="#0000FF">then</font>
<font color="#FF0055">  -- Windows code</font>
<font color="#0000FF">elsifdef </font><font color="#330033">LINUX </font><font color="#0000FF">then</font>
<font color="#FF0055">  -- LINUX code</font>
<font color="#0000FF">elsifdef </font><font color="#330033">FREEBSD </font><font color="#0000FF">or </font><font color="#330033">NETBSD </font><font color="#0000FF">then</font>
<font color="#FF0055">  -- BSD code</font>
<font color="#0000FF">elsedef</font>
<font color="#330033">    crash</font><font color="#880033">(</font><font color="#330033">"Unsupported platform"</font><font color="#880033">)</font>
<font color="#0000FF">end ifdef</font>
</pre>

<p> With parse-time evalution you get faster execution, for there is no conditional in the final code.  You can put this deeply inside a loop without penalty.  You can test for <tt>UNIX</tt> to see if the platform has <em>Unix</em>-like properties and thus will work on new <em>Unix</em>-like platforms without modification.  You can even put statements that are top-level, such as constant and routine defintions.  However, since the interpreter skips over the platforms you are not running on, syntax errors can hide in this construct and if you misspell an OS name you will not get warned.</p>

<pre class="examplecode"><font color="#0000FF">ifdef </font><font color="#330033">UNIX </font><font color="#0000FF">then</font>
<font color="#0000FF">	public constant </font><font color="#330033">SLASH=</font><font color="#330033">'/'</font>
<font color="#0000FF">	public constant </font><font color="#330033">SLASHES = </font><font color="#330033">"/"</font>
<font color="#0000FF">	public constant </font><font color="#330033">EOLSEP = </font><font color="#330033">"\n"</font>
<font color="#0000FF">	public constant </font><font color="#330033">PATHSEP = </font><font color="#330033">':'</font>
<font color="#0000FF">	public constant </font><font color="#330033">NULLDEVICE = </font><font color="#330033">"/dev/null"</font>
<font color="#0000FF">	ifdef </font><font color="#330033">OSX </font><font color="#0000FF">then</font>
<font color="#0000FF">		public constant </font><font color="#330033">SHARED_LIB_EXT = </font><font color="#330033">"dylib"</font>
<font color="#0000FF">	elsedef</font>
<font color="#0000FF">		public constant </font><font color="#330033">SHARED_LIB_EXT = </font><font color="#330033">"so"</font>
<font color="#0000FF">	end ifdef</font>
        
<font color="#0000FF">	public constant </font><font color="#330033">FOO =  SLASH == PATHSEP </font><font color="#FF0055">-- this has a hidden syntax error</font>
	
<font color="#0000FF">elsifdef </font><font color="#330033">WINDOWS </font><font color="#0000FF">then</font>

<font color="#0000FF">	public constant </font><font color="#330033">SLASH=</font><font color="#330033">'\\'</font>
<font color="#0000FF">	public constant </font><font color="#330033">SLASHES = </font><font color="#330033">"\\/:"</font>
<font color="#0000FF">	public constant </font><font color="#330033">EOLSEP = </font><font color="#330033">"\r\n"</font>
<font color="#0000FF">	public constant </font><font color="#330033">PATHSEP = </font><font color="#330033">';'</font>
<font color="#0000FF">	public constant </font><font color="#330033">NULLDEVICE = </font><font color="#330033">"NUL:"</font>
<font color="#0000FF">	public constant </font><font color="#330033">SHARED_LIB_EXT = </font><font color="#330033">"dll"</font>
	
<font color="#0000FF">elsifdef </font><font color="#330033">TRASHOS </font><font color="#0000FF">then  </font><font color="#FF0055">-- this symbol is never defined -- no error here either</font>
       
<font color="#0000FF">end ifdef</font>
</pre>

<p> In this above example, we have constant declarations which are different according to OS such things.  The line with FOO has a syntax error but your interpreter will not catch it if you are running <em>Windows</em>.  There is no OS with the name 'TRASHOS'.  I simply made it up and this construct will not warn you about mistakes like these.</p>

<p> Run-time evalution provides you something that is always syntax-checked and you can even make expressions using comparatives to avoid both parse-time and run-time branching all together.</p>

<pre class="examplecode"><font color="#330033">add_code = </font><font color="#880033">{</font>
<font color="#FF0055">    -- first int argument is at stack offset +4, 2nd int is at +8 </font>
<font color="#330033">       #8B, #44, #24, #04,                  </font><font color="#FF0055">-- mov   eax, +4[esp]</font>
<font color="#330033">       #03, #44, #24, #08,                  </font><font color="#FF0055">-- add   eax, +8[esp]</font>
<font color="#330033">       #C2, #00, #08 * </font><font color="#993333">(</font><font color="#0000FF">platform</font><font color="#0000FF">() </font><font color="#330033">= WINDOWS</font><font color="#993333">) </font><font color="#FF0055">-- ret 8  </font>
<font color="#FF0055">                                            -- pop 8 bytes off the stack</font>
<font color="#880033">}</font>
</pre>

<p> This is machine code to be put into memory as an example from <tt>.../euphoria/demo/callmach.ex</tt>.  Here if <tt>platform() = WINDOWS</tt> is true, then the code will pop 8 bytes off of the stack, if not it will pop 0 bytes off of the stack.  This has to be done because of where the function call conventions are implemented in the various compilers.  We use Watcom C for <em>Windows</em> and GCC for the others.  Now if the programmer had put a non-existent symbol, such as ARCH64, the parser would stop, point out the error, and the programmer would then fix it.</p>

<!-- ..\docs\platform.txt -->
<h3>6.10.2 The Discontinued DOS32 Platform</h3>
<a name="_642_thediscontinueddos32platform"></a><a name="thediscontinueddos32platform"></a>
<p> This platform is no longer supported.  </p>

<p> Those interested in writing DOS programs in Euphoria may use version 3.1 downloadable from the original ~RapidEuphoria website: <a class="external" href="http://www.rapideuphoria.com/v20.htm">http://www.rapideuphoria.com/v20.htm</a>.</p>

<p> The <tt>DOS32</tt> platform was for computers without <em>Windows</em> OS, and though people could still use the Euphoria binaries built for this platform on <em>Windows</em>, it was slower than and lacked features available on binaries built for the <tt>WINDOWS</tt> platform.</p>

<p> The binaries for this platform had support for low-level graphics and though DOS was 16-bit, the Euphoria binaries for <tt>DOS32</tt> used techniques that allowed you to use 32-bit addresses transparently, hence the name of the platform: <tt>DOS32</tt>.  However, in this platform you could not use dynamically loaded libraries and filenames had to be in a format of: eight letters, a dot, and three letters when creating a file.  You could not use the Windowing system even if your computer had <em>Windows</em>.  You were limited to full-sreen mode graphics and the text console.</p>

<!-- ..\docs\platform.txt -->
<h3>6.10.3 The Windows Platform</h3>
<a name="_643_thewindowsplatform"></a><a name="thewindowsplatform"></a>
<p> With the <em>Windows</em> platform, your programs can still use the <tt><em>text console</em></tt>.  Because most library routines work the same way on each platform most text mode programs can be run using the console interpreter of any platform without any change.</p>

<p> Since the Euphoria interpreter can work directly with your OS you can also create GUI programs. You can use a user submitted library from the archive or handle calls directly into the DLLs.  There are high-level graphics libraries for Direct3D and OpenGL available from the <a class="external" href="http://www.RapidEuphoria.com/archive.htm">Euphoria Web site</a>.</p>

<p> A console window will be created automatically when a <em>Windows</em> Euphoria program first outputs something to the screen or reads from the keyboard.  If your program is displaying a screen, you will also see a console window when you read standard input or write to standard output, even when these have been redirected to files. The console will disappear when your program finishes execution, or via a call to <a href="std_console.html#_971_free_console">free_console</a>.</p>

<p> If you don't want a console to appear, it might help to put the following statements at the top of your Euphoria program:</p>

<pre class="examplecode"><font color="#FF0055">-- Now, when there is input or output to the console we will get an error</font>
<font color="#FF0055">-- and see in which line number this happens. </font>
<font color="#0000FF">close</font><font color="#880033">(</font><font color="#330033">STDOUT</font><font color="#880033">)</font>
<font color="#0000FF">close</font><font color="#880033">(</font><font color="#330033">STDIN</font><font color="#880033">)</font>
</pre>

<p> Now with these lines the interpreter is forced to give you a runtime error, report where in the program the standard input or output is used.  It can be hard to find the offending I/O statement in programs that contain many commented out or debug mode only console I/O statements.</p>

<p> If you actually *want* to use the console, and there is something on the console that you want your user to read, you should prompt them and wait for his input before terminating. To prevent the console from quickly disappearing you might include a statement such as:</p>

<pre class="examplecode"><font color="#0000FF">include </font><font color="#330033">std/console.e</font>

<font color="#330033">any_key</font><font color="#880033">(</font><font color="#330033">"Press any key to close this Window"</font><font color="#880033">)</font>
</pre>

<p> which will wait for the user enters something.</p>

<p> If you want to run an interpreted Euphoria program to use the current console use <tt>eui.exe</tt> but if you want it to create a new console window use <tt>euiw.exe</tt>.</p>

<p> Programs translated by the translator for this platform will also pop up a new console whenever input is asked for our output is sent to the screen unless you specify the <tt>-CON</tt> option.</p>

<p> When running an interpreter or translator for the <em>Windows</em> platform, <tt>platform</tt> returns WINDOWS and a parsetime branch (with ifdef/end ifdef) with <tt>WINDOWS</tt> will be followed.</p>

<p> In order to use <a href="std_socket.html#socketsok">sockets</a> you must have Windows 2000 Professional or later. In order for the the routines <a href="std_console.html#_822_has_console">has_console</a> and <a href="std_console.html#_886_maybe_any_key">maybe_any_key</a> to have useful behavior you must have Windows XP or later.</p>

<!-- ..\docs\platform.txt -->
<h4>6.10.3.1 High-Level Windows Programming</h4>
<a name="_644_highlevelwindowsprogramming"></a><a name="highlevelwindowsprogramming"></a>
<p> Thanks to <strong>David Cuny</strong>, <strong>Derek Parnell</strong>, <strong>Judith Evans</strong> and many others, there's a package called <strong>Win32Lib</strong> that you can use to develop <em>Windows</em> GUI applications in Euphoria. It's remarkably easy to learn and use, and comes with good documentation and many small example programs.  </p>

<p> If you have a SVN client, you can get a Euphoria version 4.0-compatible Win32lib  at:</p>

<p> <a class="external" href="https://win32libex.svn.sourceforge.net/svnroot/win32libex/trunk">https://win32libex.svn.sourceforge.net/svnroot/win32libex/trunk</a>.  </p>

<p> Get version 68.</p>

<p> There is also an <strong>IDE</strong>, by Judith Evans for use with <strong>Win32lib</strong>. <a class="external" href="https://euvide.svn.sourceforge.net/svnroot/euvide">https://euvide.svn.sourceforge.net/svnroot/euvide</a>.</p>

<p> <strong>Matt Lewis</strong> has developed a wrapper for the wxWidgets library for Euphoria: wxEuphoria.  It is cross-platform.</p>

<p> You can download WxEuphoria, Win32Lib and Judith's IDE from the <a class="external" href="http://www.RapidEuphoria.com/archive.htm">Euphoria Web site</a>.</p>

<!-- ..\docs\platform.txt -->
<h4>6.10.3.2 Low-Level WINDOWS Programming</h4>
<a name="_645_lowlevelwindowsprogramming"></a><a name="lowlevelwindowsprogramming"></a>
<p> To allow access to <em>Windows</em> at a lower level, Euphoria provides a mechanism for calling any C function in any <em>Windows</em> API .dll file, or indeed in any 32-bit <em>Windows</em> .dll file that you create or someone else creates. There is also a call-back mechanism that lets <em>Windows</em> call your Euphoria routines. Call-backs are necessary when you create a graphical user interface.</p>

<p> To make full use of the <em>Windows</em> platform, you need documentation on 32-bit Windows programming, in particular the <em>Windows</em> Application Program Interface (API), including the C structures defined by the API. There is a large WINDOWS.HLP file (c) Microsoft that is available with many programming tools for <em>Windows</em>. There are numerous books available on the subject of <em>Windows</em> programming for C/C++. You can adapt most of what you find in those books to the world of Euphoria programming for <em>Windows</em>. A good book is <strong><em>Programming Windows by Charles Petzold</em></strong>.</p>

<p> A <em>Windows</em> API Windows help file (8 Mb) can be downloaded from <a class="external" href="ftp://ftp.borland.com/pub/delphi/techpubs/delphi2/win32.zip">ftp://ftp.borland.com/pub/delphi/techpubs/delphi2/win32.zip</a>, Borland's Web site.</p>

<!-- ..\docs\platform.txt -->
<h3>6.10.4 The Unix Platforms</h3>
<a name="_646_theunixplatforms"></a><a name="theunixplatforms"></a>
<p> As with <em>Windows</em>, you can write text on a console, or xterm window, in multiple colors and at any line or column position.</p>

<p> Just as in <em>Windows</em>, you can call C routines in shared libraries and C code can call back to your Euphoria routines.</p>

<p> You can get a Euphoria interface to high level graphics library <strong>OpenGL</strong> from the <a class="external" href="http://www.RapidEuphoria.com/archive.htm">Euphoria Web site</a>. OpenGL also works with <em>Windows</em>.</p>

<p> Easy X-windows GUI programming is available using either Irv Mullin's EuGTK interface to the GTK GUI library, or wxEuphoria developed by Matt Lewis. wxEuphoria also runs on Windows.</p>

<p> When porting code from <em>Windows</em> to <em>Unix</em>, you'll notice the following differences:</p>
<ul><li>Some of the numbers assigned to the 16 main colors in graphics.e are different. If you use the constants defined in graphics.e you won't have a problem. If you hard-code your color numbers you will see that blue and red have been switched etc.
</li><li>The key codes for special keys such as Home, End, arrow keys are different, and there are some additional differences when you run under XTERM.
</li><li>The Enter key is code 10 (line-feed) on Linux, where on Windows it was 13 (carriage-return).
</li><li>Other OSes use '/' (slash) on file paths. Windows use '\' (backslash). If you use the SLASH constant from std/filesys.e you don't have to worry about this however.
</li><li>Calls to <tt>system</tt> and <tt>system_exec</tt> that contain <em>Windows</em> commands will obviously have to be changed to the corresponding Linux or FreeBSD command. e.g. "DEL" becomes "rm", and "MOVE" becomes "mv".  Often you can use a standard library call instead and it will be portable across platforms. For example you can use <a href="std_filesys.html#filesyscreate_directory">filesys:create_directory</a> or <a href="std_filesys.html#filesysdelete_file">filesys:delete_file</a>.
</li></ul>
<p>When running an interpreter or translator for a <em>Unix</em> platform, <tt>platform</tt> will return one of the several symbols for <tt>UNIX</tt> and a parsetime branch (with ifdef/end ifdef) with <tt>UNIX</tt> and the symbol that is that of the specific OS will be followed.</p>

<p> We assume that the environment is always run from some kind of CLI in two routines: The routine <a href="std_console.html#_822_has_console">has_console</a> always returns 0, and <a href="std_console.html#_886_maybe_any_key">maybe_any_key</a> never waits for key input.</p>

<!-- ..\docs\platform.txt -->
<h3>6.10.5 Interfacing with C Code</h3>
<a name="_647_interfacingwithccode"></a><a name="interfacingwithccode"></a>
<p> On <em>Windows</em> and <em>Unix</em> it is possible to interface Euphoria code with C code. Your Euphoria program can call C routines and read and write C variables. C routines can even call ("callback") your Euphoria routines. The C code must reside in a dynamic link or shared library. By interfacing with dynamic link libraries and shared libraries, you can access the full programming interface on these systems.</p>

<p> Using the Euphoria to C Translator, you can translate Euphoria routines to C, and compile them into a shared library file. You can pass Euphoria atoms and sequences to these compiled Euphoria routines, and receive Euphoria data as a result. Translated/compiled routines typically run much faster than interpreted routines. For more information, see the <a href="e2c.html#_533_euphoriatoctranslator">Translator</a>.</p>

<!-- ..\docs\platform.txt -->
<h4>6.10.5.1 Calling C Functions</h4>
<a name="_648_callingcfunctions"></a><a name="callingcfunctions"></a>
<p> To call a C function in a shared library file you must perform the following steps: </p>
<ol><li>Open the shared library file that contains the C function by calling <a href="std_dll.html#_5445_open_dll">open_dll</a>.
</li><li>Define the C function, by calling <a href="std_dll.html#_5469_define_c_func">define_c_func</a> or <a href="std_dll.html#_5461_define_c_proc">define_c_proc</a>. This tells Euphoria the number and type of the arguments as well as the type of value returned.<br />
Euphoria currently supports all C integer and pointer types as arguments and return values. It also supports floating-point arguments and return values (C double type). It is currently not possible to pass C structures by value or receive a structure as a function result, although you can certainly pass a pointer to a structure and get a pointer to a structure as a return value. Passing C structures by value is rarely required for operating system calls.<br />
Euphoria also supports all forms of Euphoria data - atoms and arbitrarily-complex sequences, as arguments to translated/compiled Euphoria routines.
</li><li>Call the C function by calling <a href="std_dll.html#_5477_c_func">c_func</a> or <a href="std_dll.html#_5485_c_proc">c_proc</a>
</li></ol>
<pre class="examplecode"><font color="#0000FF">include </font><font color="#330033">dll.e</font>

<font color="#0000FF">atom </font><font color="#330033">user32</font>
<font color="#0000FF">integer </font><font color="#330033">LoadIcon, icon</font>

<font color="#330033">user32 = open_dll</font><font color="#880033">(</font><font color="#330033">"user32.dll"</font><font color="#880033">)</font>

<font color="#FF0055">-- The name of the routine in user32.dll is "LoadIconA".</font>
<font color="#FF0055">-- It takes a pointer and an 32-bit integers as arguments,</font>
<font color="#FF0055">-- and it returns a 32-bit integer.</font>
<font color="#330033">LoadIcon = define_c_func</font><font color="#880033">(</font><font color="#330033">user32, </font><font color="#330033">"LoadIconA"</font><font color="#330033">, </font><font color="#993333">{</font><font color="#330033">C_POINTER, C_INT</font><font color="#993333">}</font><font color="#330033">, C_INT</font><font color="#880033">)</font>

<font color="#330033">icon = </font><font color="#0000FF">c_func</font><font color="#880033">(</font><font color="#330033">LoadIcon, </font><font color="#993333">{</font><font color="#330033">NULL, IDI_APPLICATION</font><font color="#993333">}</font><font color="#880033">)</font>
</pre>

<p> See <a href="std_dll.html#_5477_c_func">c_func</a>, <a href="std_dll.html#_5485_c_proc">c_proc</a>, <a href="std_dll.html#_5469_define_c_func">define_c_func</a>, <a href="std_dll.html#_5461_define_c_proc">define_c_proc</a>, <a href="std_dll.html#_5445_open_dll">open_dll</a></p>

<p> See <tt><strong>demo\win32</strong></tt> or <tt><strong>demo/linux</strong></tt> for example programs.</p>

<p> On <em>Windows</em> there is more than one C calling convention. The Windows API routines all use the <strong>__stdcall</strong> convention. Most C compilers however have <strong>__cdecl</strong> as their default. __cdecl allows for variable numbers of arguments to be passed. Euphoria assumes __stdcall, but if you need to call a C routine that uses __cdecl, you can put a '+' sign at the start of the routine name in define_<tt>c_proc</tt> and <tt>define_c_func</tt>. In the example above, you would have "+LoadIconA", instead of "LoadIconA".</p>

<p> You can examine a <tt>dll</tt> file by right-clicking on it, and choosing "QuickView" (if it's on your system). You will see a list of all the C routines that the <tt>dll</tt> exports.</p>

<p> To find out which <strong>.</strong>dll file contains a particular <em>Windows</em> C function, run <strong>Euphoria\demo\win32\dsearch.exw</strong></p>

<!-- ..\docs\platform.txt -->
<h4>6.10.5.2 Accessing C Variables</h4>
<a name="_649_accessingcvariables"></a><a name="accessingcvariables"></a>
<p> You can get the address of a C variable using <a href="std_dll.html#_5454_define_c_var">define_c_var</a>. You can then use <a href="std_machine.html#_5727_poke">poke</a> and <a href="std_machine.html#_5640_peek">peek</a> to access the value of the variable.</p>

<!-- ..\docs\platform.txt -->
<h4>6.10.5.3 Accessing C Structures</h4>
<a name="_650_accessingcstructures"></a><a name="accessingcstructures"></a>
<p> Many C routines require that you pass pointers to structures. You can simulate C structures using allocated blocks of memory. The address returned by <a href="std_machine.html#_5607_allocate">allocate</a> can be passed as if it were a C pointer.</p>

<p> You can read and write members of C structures using <a href="std_machine.html#_5640_peek">peek</a> and <a href="std_machine.html#_5727_poke">poke</a>, or <a href="std_machine.html#_5688_peek4u">peek4u</a>, <a href="std_machine.html#_5672_peek4s">peek4s</a>, and <a href="std_machine.html#_5742_poke4">poke4</a>. You can allocate space for structures using <a href="std_machine.html#_5607_allocate">allocate</a>.<br />
You must calculate the offset of a member of a C structure. This is usually easy, because anything in C that needs 4 bytes will be assigned 4 bytes in the structure. Thus C int's, char's, unsigned int's, pointers to anything, etc. will all take 4 bytes. If the C declaration looks like:</p>

<p> 
<pre>// Warning C code ahead!

struct example {
    int a;           // offset  0
    char *b;         // offset  4
    char c;          // offset  8
    long d;          // offset 12
};
</pre>

<p> To allocate space for "struct example" you would need: </p>

<pre class="examplecode"><font color="#0000FF">atom </font><font color="#330033">p = allocate</font><font color="#880033">(</font><font color="#330033">16</font><font color="#880033">) </font><font color="#FF0055">-- size of "struct example"</font>
</pre>

<p> The address that you get from <a href="std_machine.html#_5607_allocate">allocate</a> is always at least 4-byte aligned. This is useful, since <em>Windows</em> structures are supposed to start on a 4-byte boundary. Fields within a C structure that are 4-bytes or more in size must start on a 4-byte boundary in memory. 2-byte fields must start on a 2-byte boundary. To achieve this you may have to leave small gaps within the structure. In practice it is not hard to align most structures since 90% of the fields are 4-byte pointers or 4-byte integers.</p>

<p> You can set the fields using something like: </p>

<pre class="examplecode"><font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">p + 0, a</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">p + 4, b</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">p + 8, c</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">p +12, d</font><font color="#880033">)</font>
</pre>

<p> You can read a field with something like: </p>

<pre class="examplecode"><font color="#330033">d = peek4</font><font color="#880033">(</font><font color="#330033">p+12</font><font color="#880033">)</font>
</pre>

<p> <dl>
<dt>Tip:
</dt>
<dd>For readability, make up Euphoria constants for the field offsets. See Example below.</dd>
</dl>

<pre class="examplecode"><font color="#0000FF">constant </font><font color="#330033">RECT_LEFT = 0,</font>
<font color="#330033">RECT_TOP  = 4,</font>
<font color="#330033">RECT_RIGHT = 8,</font>
<font color="#330033">RECT_BOTTOM = 12,</font>
<font color="#330033">RECT_SIZEOF = 16</font>

<font color="#0000FF">atom </font><font color="#330033">rect = allocate</font><font color="#880033">(</font><font color="#330033">RECT_SIZEOF</font><font color="#880033">)</font>

<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">rect + RECT_LEFT,    10</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">rect + RECT_TOP,     20</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">rect + RECT_RIGHT,   90</font><font color="#880033">)</font>
<font color="#0000FF">poke4</font><font color="#880033">(</font><font color="#330033">rect + RECT_BOTTOM, 100</font><font color="#880033">)</font>

<font color="#FF0055">-- pass rect as a pointer to a C structure</font>
<font color="#FF0055">-- hWnd is a "handle" to the window</font>
<font color="#0000FF">if not c_func</font><font color="#880033">(</font><font color="#330033">InvalidateRect, </font><font color="#993333">{</font><font color="#330033">hWnd, rect, 1</font><font color="#993333">}</font><font color="#880033">) </font><font color="#0000FF">then</font>
<font color="#0000FF">    puts</font><font color="#880033">(</font><font color="#330033">2, </font><font color="#330033">"InvalidateRect failed\n"</font><font color="#880033">)</font>
<font color="#0000FF">end if</font>
</pre>

<p> The Euphoria code that accesses C routines and data structures may look a bit ugly, but it will typically form just a small part of your program, especially if you use Win32Lib, EuWinGUI, or Irv Mullin's X Windows library. Most of your program will be written in pure Euphoria, which will give you a big advantage over those forced to code in C.</p>

<!-- ..\docs\platform.txt -->
<h4>6.10.5.4 Call-backs to your Euphoria routines</h4>
<a name="_651_callbackstoyoureuphoriaroutines"></a><a name="callbackstoyoureuphoriaroutines"></a>
<p> When you create a window, the <em>Windows</em> operating system will need to call your Euphoria routine.  To set this up, you must get a 32-bit "call-back" address for your routine and give it to Windows. For example (taken from <strong>demo\win32\window.exw</strong>): </p>

<pre class="examplecode"><font color="#0000FF">integer </font><font color="#330033">id</font>
<font color="#0000FF">atom </font><font color="#330033">WndProcAddress</font>

<font color="#330033">id = </font><font color="#0000FF">routine_id</font><font color="#880033">(</font><font color="#330033">"WndProc"</font><font color="#880033">)</font>

<font color="#330033">WndProcAddress = call_back</font><font color="#880033">(</font><font color="#330033">id</font><font color="#880033">)</font>
</pre>

<p> <a href="std_machine.html#_5855_routine_id">routine_id</a> uniquely identifies a Euphoria procedure or function by returning an integer value. This value can be used later to call the routine. You can also use it as an argument to the <a href="std_dll.html#_5492_call_back">call_back</a> function.</p>

<p> In the example above, The 32-bit <em>call-back address</em>, <tt>WndProcAddress</tt>, can be stored in a C structure and passed to <em>Windows</em> via the ~RegisterClass() C API function.<br />
<strong>This gives <em>Windows</em> the ability to call the Euphoria routine, ~WndProc(), whenever the user performs an action on a certain class of window.</strong> Actions include clicking the mouse, typing a key, resizing the window etc.<br />
<em>See the <strong>window.exw</strong> demo program for the whole story.</em></p>

<p> <dl>
<dt>Note:
</dt>
<dd>It is possible to get a <em>call-back address</em> for <strong><em>any</em></strong> Euphoria routine that meets the following conditions: * the routine must be a function, not a procedure * it must have from 0 to 9 parameters * the parameters should all be of type atom (or integer etc.), not sequence * the return value should be an integer value up to 32-bits in size</dd>
</dl>
You can create as many call-back addresses as you like, but you should not call <a href="std_dll.html#_5492_call_back">call_back</a> for the same Euphoria routine multiple times - each call-back address that you create requires a small block of memory.</p>

<p> The values that are passed to your Euphoria routine can be any 32-bit <tt>unsigned</tt> atoms, i.e. non-negative. Your routine could choose to interpret large positive numbers as negative if that is desirable. For instance, if a C routine tried to pass you -1, it would appear as hex FFFFFFFF. If a value is passed that does not fit the type you have chosen for a given parameter, a Euphoria type-check error may occur (depending on <a href="lang_decl.html#type_check">type_check</a>) <br />
No error will occur if you declare all parameters as <tt>atom</tt>.</p>

<p> Normally, as in the case of ~WndProc() above, <em>Windows</em> initiates these call-backs to your routines. <strong>It is also possible for a C routine in any .dll to call one of your Euphoria routines.</strong> You just have to declare the C routine properly, and pass it the call-back address.</p>

<p> Here's an example of a WATCOM C routine that takes your call-back address as its only parameter, and then calls your 3-parameter Euphoria routine:</p>

<p> 
<pre>/* 1-parameter C routine that you call from Euphoria */
unsigned EXPORT APIENTRY test1(
    LRESULT CALLBACK (*eu_callback)(unsigned a,
    unsigned b,
    unsigned c))
{
    /* Your 3-parameter Euphoria routine is called here
    via eu_callback pointer */
    return (*eu_callback)(111, 222, 333);
}
</pre>

<p> The C declaration above declares test1 as an externally-callable C routine that takes a single parameter. The single parameter is a pointer to a routine that takes 3 unsigned parameters - i.e. your Euphoria routine.</p>

<p> In WATCOM C, "CALLBACK" is the same as "__stdcall". This is the calling convention that's used to call <em>Windows</em> API routines, and the C pointer to your Euphoria routine should be declared this way too, or you'll get an error when your Euphoria routine tries to return to your .DLL.</p>

<p> If you need your Euphoria routine to be called using the __cdecl convention, you must code the call to <tt>call_back</tt> as:</p>

<pre class="examplecode"><font color="#330033">myroutineaddr = call_back</font><font color="#880033">(</font><font color="#993333">{</font><font color="#330033">'+'</font><font color="#330033">, id</font><font color="#993333">}</font><font color="#880033">)</font>
</pre>

<p> The plus sign and braces indicate the __cdecl convention. The simple case, with no braces, is __stdcall.</p>

<p> In the example above, your Euphoria routine will be passed the three values 111, 222 and 333 as arguments. Your routine will return a value to test1. That value will then be immediately returned to the caller of test1 (which could be at some other place in your Euphoria program).</p>

<p> A call-back address can be passed to the UNIX signal() function to specify a Euphoria routine to handle various signals (e.g. SIGTERM). It can also be passed to C routines such as <tt>qsort</tt>, to specify a Euphoria comparison function.</p>

<p> 
<!-- ..\docs\perform.txt -->

						</div>

						<!-- BEGIN NAV -->
						<div class="doc-tools">
							<table border=0 padding=0 cellpadding=0 width="100%">
								<tr>
									<td><a href="trouble.html"><img src="images/prev.png" /></a></td>
									<td><a href="miniguide.html">Up</a></td>
									<td><a href="perform.html"><img src="images/next.png" /></a></td>
									<!-- Spacer -->
									<td width="100%" colspan="3">&nbsp;</td>
									<td><a href="index.html">TOC</a></td>
									<td><a href="key_index.html">Index</a></td>
								</tr>
								<tr>
									<td width="20%" colspan="3">
										&lt;&lt;
										<a href="syntax_toc.html">5 Formal Syntax</a>
									</td>
									<td width="20%">
										&lt;
										<a href="trouble.html">6.9 Euphoria Trouble-Shooting Guide</a>
									</td>
									<td width="20%">
										Up: <a href="miniguide.html">6 Mini-Guides</a>
									</td>
									<td width="20%">
										<a href="perform.html">6.11 Performance Tips</a>
										&gt;
									</td>
									<td width="20%" colspan="2">
										<a href="tools.html">7 Included Tools</a>
										&gt;&gt;
									</td>
								</tr>
							</table>
						</div>
						<!-- END NAV -->
			</div>
		</div>
	</div>
</body>
</html>
